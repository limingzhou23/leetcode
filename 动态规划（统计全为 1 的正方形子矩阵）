给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。
示例 1：
输入：matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
输出：15
解释： 
边长为 1 的正方形有 10 个。
边长为 2 的正方形有 4 个。
边长为 3 的正方形有 1 个。
正方形的总数 = 10 + 4 + 1 = 15.

分析：我们用 f[i][j] 表示以 (i, j) 为右下角的正方形的最大边长，那么除此定义之外，f[i][j] = x 也表示以 (i, j) 为右下角的正方形的数目为 x
原因是正好代表以此处为右下角点且边长为 1, 2, ..., x 的正方形各一个。
在计算出所有的 f[i][j] 后，我们将它们进行累加，就可以得到矩阵中正方形的数目。
我们尝试挖掘 f[i][j] 与相邻位置的关系来计算出 f[i][j] 的值。

f[i][j - 1] >= f[i][j] - 1
f[i - 1][j] >= f[i][j] - 1
f[i - 1][j - 1] >= f[i][j] - 1
将这三个不等式联立，可以得到：
min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1])>=f[i][j] - 1
这是我们通过固定 f[i][j] 的值，判断其相邻位置与之的关系得到的不等式。同理，我们也可以固定 f[i][j] 相邻位置的值，得到另外的限制条件。
同理分析可知 f[i][j] - 1>=min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1])
得出转移方程为  f[i][j]=min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1])+1

如果某点为0那么此处不可能产生正方形
左侧和上侧边界点处正方形数目和该点数字相同

分类：动态规划题目 求解状态转移方程
     注意python相对应的语法知识






class Solution(object):
    def countSquares(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        m, n = len(matrix), len(matrix[0])
        f = [[0] * n for _ in range(m)]
        ans = 0
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    f[i][j] = matrix[i][j]
                elif matrix[i][j] == 0:
                    f[i][j] = 0
                else:
                    f[i][j] = min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1]) + 1
                ans += f[i][j]
        return ans
