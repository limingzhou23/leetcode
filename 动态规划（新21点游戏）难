爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 
抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 
每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

示例 1：
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。

示例 2：
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。

示例 3：
输入：N = 21, K = 17, W = 10
输出：0.73278

题目类型：动态规划
核心：找状态转移方程

爱丽丝获胜的概率只和下一轮开始前的得分有关，因此根据得分计算概率。
令dp[x]表示从得分为 x的情况开始游戏并且获胜的概率，目标是求dp[0]的值。
根据规则，当分数达到或超过 K时游戏结束，游戏结束时，如果分数不超过 N则获胜，如果分数超过 N则失败。
因此当K≤x≤min(N,K+W−1) 时有 dp[x]=1，当 x>min(N,K+W−1) 时有 dp[x]=0。
为什么分界线是 min(N,K+W−1)？
首先，只有在分数不超过 N时才算获胜；其次，可以达到的最大分数为K+W−1，即在最后一次抽取数字之前的分数为K−1，并且抽到了W。
当 0≤x≤K 时，如何计算 dp[x]的值？
注意到每次在范围 [1, W][1,W] 内随机抽取一个整数，且每个整数被抽取到的概率相等，因此可以得到如下状态转移方程：
                  dp[x]=(dp[x+1]+dp[x+2]+....+dp[x+W])/W
                  
上述解法的时间复杂度是 O(N+KW)O(N+KW)，会超出时间限制，因此需要优化。

考虑对 dp的相邻项计算差分，有如下结果：
                dp[x]-dp[x+1]=(dp[x+1] - dp[x+W+1])/W  其中 0≤x<K−1。
因此可以得到新的状态转移方程：
              dp[x]=dp[x+1]-(dp[x+W+1]-dp[x+1])/W      其中0≤x<K−1。
注意到上述状态转移方程中 x的取值范围，当 x=K-1时不适用。因为这个等式看取值范围只能得到dp[K-1]的值，而实际上dp[K-1]需要dp[K]的值，dp[K]不在求取范围内
因此对于 dp[K-1]的值，需要通过
              dp[K-1]=（dp[K]+dp[K+1]+...+dp[K+W-1])/W   计算得到。
注意到只有当 K≤x≤min(N,K+W−1) 时才有 dp[x]=1，因此
              dp[K-1]=(min(N, K+W-1) - K + 1)/W = min(N-K+1,W)/W
可在 O(1)时间内计算得到 dp[K-1]的值。
对于 dp[K-2]到 dp[0]的值，则可通过新的状态转移方程得到。

代码：
    def new21Game(self, N: int, K: int, W: int) -> float:
        if K == 0:
            return 1.0
        dp = [0.0] * (K + W + 1)
        for i in range(K, min(N, K + W - 1) + 1):
            dp[i] = 1.0
        dp[K-1]=float(min(N-K+1,W))/W
        for i in range(K - 2, -1, -1):
            dp[i] = dp[i + 1] - (dp[i + W + 1] - dp[i + 1]) / W
        return dp[0]
